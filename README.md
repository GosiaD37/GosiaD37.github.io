<p align="center">
  <img src="ePortfolio Pictures/Screenshot_20250715_073506_Picsart.jpg" alt="Profile Picture" width="200" height="200" style="border-radius: 50%;">
</p>



# Malgorzata Debska

## <center>CS-499 Computer Science Capstone | Southern New Hampshire University</center>

---

## Table of Contents

- [Professional Self-Assessment](#professional-self-assessment)  
- [Enhancement One - Software Design and Engineering (CS-410)](#enhancement-one-software-design-and-engineering-cs-410)  
- [Code Review Video - CS-410](#code-review-video-cs-410)  
- [Enhancement Two - Algorithms and Data Structures (CS-340)](#enhancement-two-algorithms-and-data-structures-cs-340)  
- [Code Review Video - CS-340](#code-review-video-cs-340)  
- [Enhancement Three - Databases (CS-405)](#enhancement-three-databases-cs-405)  
- [Code Review Video - CS-405](#code-review-video-cs-405)  

---

##  **Professional Self-Assessment**



Over the past three years in the Computer Science program, I have experienced a truly transformative journey, one that has challenged me to grow as a problem solver, a collaborator, and a professional in the field of technology. What began as an interest in understanding how software works has evolved into a deep, multifaceted skill set spanning software development, algorithms, databases, security, and effective communication with diverse stakeholders.

Throughout my coursework, I have worked on projects that reflect the real-world complexity of computer science. In collaborative environments, I learned the importance of version control, clear communication, and the ability to merge different coding styles and perspectives into a cohesive final product. These experiences sharpened my ability to operate effectively in team settings, balancing leadership and cooperation depending on the needs of the project.

Equally important has been my development in communicating with stakeholders translating technical challenges into clear, actionable language. I have engaged in requirements gathering, status reporting, and solution presentations, always keeping the end user in mind. This skill has proven essential not only for ensuring that technical solutions meet business needs but also for establishing trust and clarity between technical and non-technical audiences.

**Growth Through Coursework and ePortfolio Development**

From my first introductory programming assignments to the complex, multi-component projects in my capstone, I have consistently challenged myself to take on work that demonstrates both depth and breadth of skill. Building my ePortfolio required me to revisit and enhance prior work, which reinforced my understanding of software engineering principles and gave me the opportunity to implement industry best practices.

One of the most valuable aspects of this process has been seeing my progression from writing functional code to designing maintainable, modular, and scalable solutions. The act of improving my artifacts was not just about cleaner code; it was about developing the mindset of a professional who anticipates future requirements, considers the user’s needs, and applies systematic approaches to problem-solving.

**Collaborating in a Team Environment**

Team-based projects in my coursework taught me the importance of collaboration, version control, and role adaptability. I worked in environments where tasks were divided across team members, requiring consistent integration of different coding styles and ideas. Using tools like Git, I learned how to merge contributions smoothly, resolve conflicts, and maintain code integrity. These experiences also helped me understand that successful collaboration depends on clear communication, mutual respect, and an openness to feedback, skills I will carry into any professional setting.

**Communicating with Stakeholders**

My projects often involved translating technical concepts for non-technical audiences, such as explaining database structures, system limitations, or algorithm efficiency to stakeholders with varying levels of technical expertise. This taught me to use precise but accessible language, highlight the “why” behind technical decisions, and ensure that project deliverables aligned with stakeholder needs. In real-world development, this skill is just as critical as writing quality code, because even the most robust system is ineffective if its value is not understood by those it serves.

**Data Structures and Algorithms**

Throughout the program, I gained a deep appreciation for the importance of algorithmic efficiency and proper data structure selection. I learned how to weigh trade-offs in performance, scalability, and memory usage. These skills were particularly evident in my capstone work, where I implemented optimized database queries and filtering algorithms to improve application responsiveness. Understanding these concepts allows me to design systems that not only work but work efficiently under real-world constraints.

**Software Engineering and Database Skills**
My coursework in software engineering emphasized the value of modular design, code reusability, and systematic testing. I applied these principles in both front-end and back-end contexts, ensuring that my applications were both functional and maintainable. In database-related projects, I gained experience with both SQL and NoSQL systems, focusing on schema design, query optimization, and data integrity. Integrating databases into larger software solutions allowed me to bridge the gap between persistent data storage and dynamic application behavior.

**Security Awareness**
Security considerations were embedded in many of my projects, reinforcing that security is not a final step but an ongoing requirement in every stage of development. From managing authentication to preventing SQL injection and securing sensitive data in transit and at rest, I learned to adopt a proactive security mindset. This approach is critical for protecting both the organization’s assets and the trust of its users.

## *How My Artifacts Fit Together*  ##
  
The artifacts in my ePortfolio collectively showcase the range of my skills:

**Algorithms and Data Structures:** Demonstrating database integration with optimized querying and interactive data visualization.

**Software Engineering and Design:** Showing modular, user focused application development with robust input validation and error handling.

**Databases:** Illustrating secure, efficient, and scalable database interaction within software systems.

Together, these artifacts form a cohesive narrative of my abilities: I can design and implement full-stack solutions that are efficient, maintainable, secure, and user-oriented. Each artifact builds on the same professional values, clarity, adaptability, and quality, that I will bring to my future work.


# <pre align="center">Enhancement One: Software Design and Engineering</pre>

## <pre align="center">CS 410</pre>


<center>
  <img src="ePortfolio Pictures/1000004989.jpg">
</center>

<code>You can see the orginal and enhanced code <a href="https://github.com/GosiaD37/GosiaD37.github.io/tree/main/Software%20Engineering%20and%20Design
">here</a>.</code>  







The artifact I selected from CS-410: Software Reverse Engineering is an in-depth project focused on analyzing and deconstructing a software program using both static and dynamic analysis techniques. This project required me to reverse engineer a compiled application by interpreting low-level code and reconstructing its high-level logic. I used tools to disassemble and examine the executable, which allowed me to understand how the software functioned without access to the original source code. Through this process, I learned to think critically and carefully dissect software in a way that exposed its logic, functions, and potential vulnerabilities.
I decided to include this project in my ePortfolio because it represents a unique and highly relevant skill set in the world of software engineering. Being able to reverse engineer a program and analyze its behavior, especially without having access to the source code, is an important ability in fields like cybersecurity and legacy software maintenance. This artifact shows how I can look at software from a forensic perspective, figure out what it does and how it works, and communicate those findings in a clear, technical manner.

In preparing the project for my ePortfolio, I enhanced the original version by expanding the documentation and making the structure of the report easier to follow. I reorganized the findings so that the conclusions were grouped by function, rather than just listed in the order I discovered them. I also went back into the decompiled code to add inline comments that explained what each block of code was doing, which made the report much more accessible to readers who may not be familiar with reverse engineering. Working on this artifact helped me meet several key course outcomes, especially in terms of critical thinking, technical documentation, and applying systematic problem solving techniques. Improving the clarity and structure of my analysis, I also showed my ability to communicate complex information in a way that’s easier to understand and useful to others. These enhancements made the project more professional and polished, which is exactly what I wanted for my portfolio. Looking back on the process, I realized how much I’ve grown since I first worked on this project. Initially, I struggled to understand some of the lower level binary patterns and how they relate to the software's higher-level logic. But by sticking with it and using the tools and knowledge I gained throughout the course, I built up the confidence to work through those challenges. I also came to appreciate how important clear documentation is, especially in technical fields where others may need to understand and build upon your work.

The original version of this program was a straightforward console application that printed a hardcoded multiplication table from 1 to 9. All of the logic was contained inside the <code>main()</code> function, which simply looped through two variables and displayed the results. While it worked, it lacked flexibility, had no input handling, and offered no real-world usability beyond the fixed output. If the user wanted a different range or to store results, the code would have to be rewritten manually.

For the enhancement, my goal was to transform this simple script into a **more dynamic, user-driven, and maintainable application** while demonstrating cleaner programming practices. I began by restructuring the program into multiple, clearly defined functions:

- <code>displayMultiplicationTable(int start, int end)</code> — Responsible only for generating and displaying the multiplication table for a given range. This separation made the logic easier to test and maintain.

- <code>getValidatedInput(const string& prompt)</code> — Added to ensure that all inputs were valid integers. It uses <code>cin.fail()</code> checks, clears error flags, and flushes the input buffer so the program never crashes on bad input. This greatly improved the program’s **robustness and user-friendliness.**

- <code>saveTableToFile(int start, int end, const string& filename)</code> — A new feature that lets the user store the generated table in a text file. It validates file access, writes the formatted table, and gives a confirmation message once saving is complete.

In addition to modularization, I expanded the program’s **customization capabilities.** Instead of being locked to the 1–9 range, the user is now prompted to enter a start and end value for the multiplication table. This flexibility makes the program useful in more contexts whether for basic math drills, larger multiplication sets, or even partial ranges for focused practice. I also implemented a **logical check** to ensure that the start value is not greater than the end value, providing immediate feedback if the range is invalid.

From a user experience perspective, I added an interactive prompt at the end asking whether the table should be saved to a file. This additional layer of choice makes the program feel more like a practical tool than just a coding exercise. For instance, a user can quickly generate a large table and store it for later reference, study, or printing.

Introducing **error handling, file I/O**, and **structured design**, the enhanced version is far more professional and maintainable. The improvements not only demonstrate my ability to **refactor procedural code into a modular structure**, but also highlight skills in **input validation, file operations, and user interaction design**. This transformation turned what was once a static.

# Code Review Video - CS-410


Below is a link directly to my YouTube page where I uploaded my Code Review 

This video was built using You Tube https://youtu.be/SzGRhwiYMFY





# <pre align="center">Enhancement Two: Algorithms and Data Structures</pre>

## <pre align="center">CS 340</pre>

<center>
  <img src="ePortfolio Pictures/1000004986.jpg">
</center>



<code>You can see the orginal and enhanced code <a href="https://github.com/GosiaD37/GosiaD37.github.io/tree/main/Algorithms%20and%20Data%20Structures">here</a>.</code>  

The second artifact I selected for my ePortfolio is a web-based CRUD (Create, Read, Update,
Delete) application originally developed in CS-340: Client-Server Development. This project
was created using Python, Flask, and MongoDB, with a Dash web interface to visualize animal
shelter data. The application provides interactive features for users to view and filter animals
suited for rescue tasks, such as water or mountain rescue. The initial version was completed
during the course, but I enhanced and restructured it to better demonstrate my evolving technical
skills.
I chose to include this artifact because it reflects my growth as a full-stack developer, especially
in applying algorithms and data structure concepts in real-world scenarios. While the original
version functioned correctly, its logic for querying and filtering data was tightly coupled to the
event callbacks and lacked modularity. In the enhanced version, I made several improvements,
particularly to the algorithms used for filtering and the data structures used to represent
conditions and operations.

## Key Enhancements ##

1. **Modular Algorithm Design:**
In the original version, MongoDB queries for filtering animals based on rescue type (e.g.,
water, mountain, disaster rescue) were directly embedded within the event handler
callbacks. This approach made the logic harder to maintain and reuse. In the enhanced
version, I modularized these queries by creating dedicated functions like
<code>query_water_rescue()</code>, <code>query_mountain_rescue()</code>, and <code>query_disaster_rescue().</code>
Each function returns a structured MongoDB query in the form of a Python dictionary. This
change improved the algorithm’s clarity and reusability.

3. **Efficient Use of Data Structures:**
I used Python’s dictionary and list structures to represent complex query conditions with
logical operators like <code>$and</code>, <code>$in</code>, <code>$gte</code>, and <code>$lte</code>. For example, breeds eligible for water
rescue are stored as a list within a dictionary condition using the $in operator. This
approach makes the code more flexible and aligns with best practices for managing datadriven logic.
4. **Code Readability and Maintainability:**
I added structured inline comments, improved function naming conventions, and
introduced visual separators to make the code easier to follow. These improvements help
others (and my future self) understand the logic more quickly and make future updates
less error prone.
5. **UI and Layout Enhancements:**
Although the main focus was on algorithm and data structure improvements, I also
enhanced the UI consistency by refining layout structure and visual hierarchy. I
reorganized the layout components and updated the placement of interactive elements
like maps, dropdowns, and data tables to improve user experience.

This artifact demonstrates my skills in creating modular, maintainable code and in designing
custom algorithms that solve a practical problem, filtering animal data for specific rescue tasks.
The enhancements I made clearly show my ability to transform procedural logic into modular
algorithms, while effectively using Python’s built-in data structures to represent complex, nested
conditions. At the beginning of the course, I planned to meet the course outcome related to
designing and analyzing algorithms and data structures for efficiency and maintainability. This
enhancement meets that outcome by:
- Refactoring procedural logic into discrete algorithmic functions,
- Using structured data (dicts and lists) for query construction,
- Supporting scalable, maintainable code practices.

At this time, I have no updates to my outcome-coverage plans, as this enhancement fully
supports my original goal.
Enhancing this artifact taught me the value of writing modular code and how critical it is to
separate logic from implementation details. By extracting logic into standalone functions, I now
better understand how to organize software components for readability, reuse, and testing.
A key challenge I faced was determining how to restructure the query logic without breaking
existing functionality. Testing each enhancement incrementally helped ensure correctness. I also
had to ensure that the logic accurately filtered animals by age, sex, and breed requiring careful
use of MongoDB’s query syntax.
Ultimately, this enhancement strengthened both my technical and problem solving skills. It
transformed a working project into a more professional and maintainable application that
demonstrates my ability to work with algorithms, data structures, and full-stack web
development.

# Code Review Video - CS-340

Below is a link directly to my YouTube page where I uploaded my Code Review 

This video was built using You Tube 


# <pre align="center">Enhancement Three: Databases</pre>

## <pre align="center">CS 405</pre>

<center>
  <img src="ePortfolio Pictures/1000004985.jpg">
</center>

<code>You can see the orginal and enhanced code <a href="https://github.com/GosiaD37/GosiaD37.github.io/tree/main/Databases">here</a>.</code>  

For the final category, I selected a contact management system that I initially created in CS-405. It tests the behavior of a dynamic collection using the <code>std::vector</code> class and the Google Test framework. This test suite is designed to verify operations like adding elements, resizing the collection, clearing values, checking capacity, and handling exceptions. Although not tied to a formal database system, the project simulates key behaviors of a data structure management system that would underlie many database operations.

The original project served as a demonstration of test-driven development, dynamic memory management, and the power of the <code>std::vector</code> class. My enhancement goal was to improve the suite’s coverage and robustness, adding more comprehensive tests and clearer documentation. I refactored some of the existing test cases to be more readable and grouped tests logically.
As part of this milestone, I significantly improved the artifact by enhancing the codebase in
NEWtest.cpp. To strengthen the original code, I made several numbers of key improvements:

- I added clear and detailed inline documentation throughout the test suite to explain the
purpose and logic of each function and test case.
- I expanded exception handling by writing tests that explicitly check for errors, such as
accessing invalid indices <code>(std::out_of_range)</code> and attempting to reserve memory beyond
the collection’s maximum capacity <code>(std::length_error).</code>
- I incorporated defensive programming practices, such as validating preconditions,
confirming expected outcomes after each operation, and designing tests that handle edge
cases gracefully.
- To increase test coverage and scalability, I introduced parameterized tests that
automatically run multiple scenarios using different input sizes (0, 1, 5, and 10).
- I improved the readability of the code by refining test case names to clearly reflect their
purpose, such as ResizeIncreasesCollectionSize and AssignValuesToCollection.
- I reinforced proper memory management by using <code>std::unique_ptr</code> for the collection,
along with structured setup and teardown methods to ensure a clean test environment for
each case.

These enhancements significantly improved the clarity, maintainability, and reliability of the
code. They also reflect my understanding of software engineering best practices and my ability
to apply those practices in a meaningful way.
This artifact directly supports the course outcomes I set out to achieve in Module One. I applied
modular design, test-driven development principles, and robust error handling. The
enhancements I made helped me go beyond simply writing tests I learned to think critically
about edge cases, failure conditions, and the long-term sustainability of the code. At this point, I
do not have any updates to my outcome-coverage plans, as this artifact fully demonstrates the
skills I intended to strengthen.

Reflecting on the enhancement process, I gained a deeper understanding of how valuable
thorough testing and thoughtful design can be in ensuring software quality. One of the challenges
I faced was determining how to best simulate database, like operations within a C++ environment
that doesn't use a database engine. I focused on core behaviors like adding entries, resizing
collections, and validating boundaries, and ensured these were covered by meaningful,
automated tests.

This process helped me transition from simply making code “work” to engineering code that is
reliable, readable, and resilient. It reinforced the idea that strong testing and defensive design
aren’t optional, they are essential to building professional grade software. Overall, this artifact
reflects not just my technical growth but also my evolving mindset as a developer who prioritizes
quality, clarity, and long-term maintainability

# Code Review Video - CS-405


Below is a link directly to my YouTube page where I uploaded my Code Review 

This video was built using You Tube https://youtu.be/krFubb637Y8





---

### Thank you for visiting my ePortfolio!  
I look forward to using these skills and experiences in my future career.

---




